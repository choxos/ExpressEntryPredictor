{% extends 'base.html' %}

{% block title %}Express Entry Predictions - AI Forecasts{% endblock %}

{% block extra_css %}
<!-- Cache busting and refresh meta tags -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<style>
.category-tab-content {
    min-height: 400px;
}

.prediction-card {
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    background: white;
    border: 1px solid #e9ecef;
}

.prediction-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.1) !important;
}

.model-prediction-item {
    background: white !important;
    border: 1px solid #e9ecef !important;
}

.model-prediction-item:hover {
    background: #f8f9fa !important;
}

.model-badge {
    font-size: 0.8rem;
    padding: 0.25rem 0.5rem;
}

.confidence-bar {
    height: 8px;
    border-radius: 4px;
    background: linear-gradient(90deg, #e9ecef 0%, #6c757d 50%, #0d6efd 100%);
    position: relative;
    overflow: hidden;
}

.confidence-indicator {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 4px;
}

.nav-tabs .nav-link {
    border-radius: 8px 8px 0 0;
    margin-right: 2px;
}

.nav-tabs .nav-link.active {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    border-color: #007bff;
}

.tab-pane {
    border: 1px solid #dee2e6;
    border-top: none;
    border-radius: 0 0 8px 8px;
    background: white;
    padding: 1.5rem;
}

.prediction-timeline-item {
    border-left: 3px solid #007bff;
    padding-left: 1rem;
    margin-bottom: 1rem;
    position: relative;
}

.prediction-timeline-item::before {
    content: '';
    position: absolute;
    left: -6px;
    top: 8px;
    width: 9px;
    height: 9px;
    border-radius: 50%;
    background: #007bff;
}

.uncertainty-range {
    font-size: 0.85rem;
    color: #6c757d;
}

.invitation-highlight {
    background: linear-gradient(135deg, #e8f5e8, #f0f9f0);
    border-left: 3px solid #28a745;
    padding: 0.5rem;
    border-radius: 0 6px 6px 0;
}

.crs-highlight {
    background: linear-gradient(135deg, #fff3cd, #fefefe);
    border-left: 3px solid #ffc107;
    padding: 0.5rem;
    border-radius: 0 6px 6px 0;
}
</style>
{% endblock %}

{% block content %}
<!-- Header Section -->
<section class="hero-section">
    <div class="container">
        <div class="row">
            <div class="col-12 text-center">
                <h1 class="display-5 fw-bold mb-3">
                    <i class="fas fa-crystal-ball me-3"></i>
                    Express Entry Predictions by Category
                </h1>
                <p class="lead mb-0">
                    Enhanced AI forecasts using LSTM, SARIMA, Prophet, Gaussian Process, and advanced ensemble models with clean features and uncertainty quantification
                </p>
            </div>
        </div>
    </div>
</section>

<!-- Control Section -->
<section class="container mb-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="row align-items-center">
                        <div class="col-md-6">
                            <label for="timeframe" class="form-label">Prediction Timeframe:</label>
                            <select class="form-select" id="timeframe">
                                <option value="next_month">Next Month</option>
                                <option value="next_quarter">Next Quarter</option>
                                <option value="rest_of_year" selected>Rest of Year</option>
                            </select>
                        </div>
                        <div class="col-md-6 d-flex align-items-end">
                            <button class="btn btn-primary w-100" onclick="refreshPredictions()">
                                <i class="fas fa-sync-alt me-2"></i>Refresh Predictions
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Category Tabs -->
<section class="container mb-5">
    <div class="row">
        <div class="col-12">
            <div class="loading-spinner" id="predictionsLoading" style="display: block;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading predictions...</span>
                </div>
                <p class="mt-2">Generating AI predictions...</p>
            </div>
            
            <div id="categoryTabsContainer" style="display: none;">
                <!-- Category Navigation Tabs -->
                <ul class="nav nav-tabs" id="categoryTabs" role="tablist">
                    <!-- Tabs will be dynamically generated -->
                </ul>
                
                <!-- Tab Content -->
                <div class="tab-content" id="categoryTabContent">
                    <!-- Tab panes will be dynamically generated -->
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Selected Category Performance -->
<section class="container mb-5">
    <div class="row">
        <div class="col-12">
            <h3 class="mb-4">
                <i class="fas fa-cogs me-2 text-primary"></i>
                <span id="selectedCategoryTitle">Category Performance Overview</span>
            </h3>
        </div>
    </div>
    
    <div class="row" id="modelPerformance">
        <!-- Model performance cards will be inserted here -->
    </div>
</section>

<!-- Category Timeline Chart -->
<section class="container mb-5">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-line me-2"></i>
                        <span id="chartTitle">Prediction Timeline</span>
                    </h5>
                </div>
                <div class="card-body">
                    <div id="timelineChart" style="height: 500px;"></div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_js %}
<script>
let allPredictions = [];
let currentCategory = null;
let categories = [];

document.addEventListener('DOMContentLoaded', function() {
    loadPredictions();
    
    // Add event listener for timeframe filtering
    document.getElementById('timeframe').addEventListener('change', filterByTimeframe);
});

async function loadPredictions() {
    const loading = document.getElementById('predictionsLoading');
    const tabsContainer = document.getElementById('categoryTabsContainer');
    
    loading.style.display = 'block';
    tabsContainer.style.display = 'none';
    
    try {
        // Add timestamp to prevent caching
        const timestamp = new Date().getTime();
        const response = await axios.get(`/api/predict/?t=${timestamp}`);
        const apiData = response.data;
        
        if (apiData.success && apiData.data && Array.isArray(apiData.data)) {
            console.log('Raw API data:', apiData.data);
            
            // Transform API data to match expected structure
            allPredictions = apiData.data.map(categoryData => {
                // Ensure predictions array exists and has data
                const predictions = categoryData.predictions || [];
                
                return {
                    id: categoryData.category_id,
                    category_name: categoryData.category_name,
                    category: {
                        id: categoryData.category_id,
                        name: categoryData.category_name,
                        description: categoryData.category_description
                    },
                    predictions: predictions,
                    recent_draws: categoryData.recent_draws || [],
                    last_updated: categoryData.last_updated
                };
            });
            
            console.log('Transformed predictions:', allPredictions);
            
            loading.style.display = 'none';
            tabsContainer.style.display = 'block';
            
            createCategoryTabs();
            
        } else {
            throw new Error('No prediction data available');
        }
        
    } catch (error) {
        loading.style.display = 'none';
        console.error('Error loading predictions:', error);
        
        document.getElementById('categoryTabsContainer').innerHTML = `
            <div class="alert alert-danger text-center">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Error loading predictions: ${error.message}. 
                <br><br>
                <strong>Try these steps:</strong>
                <ol class="text-start mt-2 small">
                    <li>Press <kbd>Ctrl+F5</kbd> (or <kbd>Cmd+Shift+R</kbd> on Mac) to hard refresh</li>
                    <li>Clear your browser cache and reload</li>
                    <li>Check the browser console (F12) for detailed error messages</li>
                </ol>
            </div>
        `;
    }
}

function createCategoryTabs() {
    const tabsNav = document.getElementById('categoryTabs');
    const tabsContent = document.getElementById('categoryTabContent');
    
    tabsNav.innerHTML = '';
    tabsContent.innerHTML = '';
    
    // Filter out categories with no predictions
    const validCategories = allPredictions.filter(cat => cat.predictions && cat.predictions.length > 0);
    
    if (validCategories.length === 0) {
        tabsContent.innerHTML = `
            <div class="alert alert-info text-center">
                <i class="fas fa-info-circle me-2"></i>
                No predictions available. Try refreshing or check back later.
            </div>
        `;
        return;
    }
    
    validCategories.forEach((categoryData, index) => {
        const categoryName = categoryData.category_name;
        const categoryId = `category-${categoryData.id}`;
        const isActive = index === 0;
        
        // Create tab navigation
        const tabNav = document.createElement('li');
        tabNav.className = 'nav-item';
        tabNav.innerHTML = `
            <button class="nav-link ${isActive ? 'active' : ''}" 
                    id="${categoryId}-tab" 
                    data-bs-toggle="tab" 
                    data-bs-target="#${categoryId}" 
                    type="button" 
                    role="tab" 
                    aria-controls="${categoryId}" 
                    aria-selected="${isActive}">
                <i class="fas fa-folder me-2"></i>
                ${abbreviateCategoryName(categoryName)}
                <span class="badge bg-light text-dark ms-2">${categoryData.predictions.length}</span>
            </button>
        `;
        
        // Add click event to update performance and chart
        tabNav.querySelector('.nav-link').addEventListener('click', () => {
            currentCategory = categoryData;
            updateCategoryContent(categoryData);
        });
        
        tabsNav.appendChild(tabNav);
        
        // Create tab content
        const tabPane = document.createElement('div');
        tabPane.className = `tab-pane fade ${isActive ? 'show active' : ''}`;
        tabPane.id = categoryId;
        tabPane.setAttribute('role', 'tabpanel');
        tabPane.setAttribute('aria-labelledby', `${categoryId}-tab`);
        
        // Load category content asynchronously
        createCategoryContent(categoryData).then(content => {
            tabPane.innerHTML = content;
        }).catch(error => {
            console.error('Error loading category content:', error);
            tabPane.innerHTML = `
                <div class="alert alert-danger text-center">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading predictions for ${categoryData.category_name}
                </div>
            `;
        });
        tabsContent.appendChild(tabPane);
        
        // Set initial category for performance display
        if (isActive) {
            currentCategory = categoryData;
            updateCategoryContent(categoryData);
        }
    });
}

async function createCategoryContent(categoryData) {
    const categoryName = categoryData.category_name;
    const predictions = categoryData.predictions || [];
    
    // Fetch recent draws directly from API instead of using category data
    let recentDraws = [];
    try {
        const drawsResponse = await fetch('/api/draws/');
        const drawsData = await drawsResponse.json();
        const allDraws = Array.isArray(drawsData) ? drawsData : drawsData.results || [];
        
        // Filter draws for this category and get the 5 most recent
        recentDraws = allDraws
            .filter(draw => draw.category_name === categoryName)
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .slice(0, 5);
    } catch (error) {
        console.error('Error fetching recent draws:', error);
        recentDraws = categoryData.recent_draws || []; // Fallback to category data
    }
    
    if (predictions.length === 0) {
        return `
            <div class="alert alert-warning text-center">
                <i class="fas fa-exclamation-triangle me-2"></i>
                No predictions available for ${categoryName}
            </div>
        `;
    }
    
    // Group predictions by model for better organization
    const predictionsByModel = {};
    predictions.forEach(pred => {
        const modelName = pred.model_used || 'Unknown Model';
        if (!predictionsByModel[modelName]) {
            predictionsByModel[modelName] = [];
        }
        predictionsByModel[modelName].push(pred);
    });
    
    let content = `
        <div class="category-tab-content">
            <div class="row mb-4">
                <div class="col-md-8">
                    <h4 class="mb-3">${categoryName}</h4>
                    <p class="text-muted">${categoryData.category.description || 'AI-powered predictions for this Express Entry category'}</p>
                </div>
                <div class="col-md-4">
                    <div class="card bg-light">
                        <div class="card-body text-center">
                            <h6 class="card-title">Category Statistics</h6>
                            <div class="row">
                                <div class="col-4">
                                    <strong>${predictions.length}</strong><br>
                                    <small class="text-muted">Total Predictions</small>
                                </div>
                                <div class="col-4">
                                    <strong>${Object.keys(predictionsByModel).length}</strong><br>
                                    <small class="text-muted">Models Used</small>
                                </div>
                                <div class="col-4">
                                    <strong>${calculateAverageInvitations(predictions)}</strong><br>
                                    <small class="text-muted">Avg. Invitations</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
    `;
    
    // Recent draws section
    if (recentDraws.length > 0) {
        content += `
            <div class="row mb-4">
                <div class="col-12">
                    <h5><i class="fas fa-history me-2"></i>Recent Draws</h5>
                    <div class="table-responsive">
                        <table class="table table-sm table-striped">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>CRS Score</th>
                                    <th>Invitations</th>
                                    <th>Round #</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${recentDraws.map(draw => `
                                    <tr>
                                        <td>${formatDate(draw.date)}</td>
                                        <td><strong>${draw.lowest_crs_score}</strong></td>
                                        <td>${draw.invitations_issued ? draw.invitations_issued.toLocaleString() : 'N/A'}</td>
                                        <td>#${draw.round_number}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
    }
    
    // ðŸŽ¯ RECURSIVE FORECASTING: Handle new prediction structure
    // Sort by rank (1 = PRIMARY, 2-5 = SECONDARY)
    const sortedPredictions = predictions.sort((a, b) => {
        return (a.rank || 0) - (b.rank || 0);
    });
    
    // Separate PRIMARY and SECONDARY predictions
    const primaryPrediction = sortedPredictions.find(p => p.is_primary === true || p.rank === 1);
    const secondaryPredictions = sortedPredictions.filter(p => p.is_primary !== true && p.rank > 1);
    
    content += `
        <div class="row mb-4">
            <div class="col-12">
                <h5><i class="fas fa-brain me-2"></i>ðŸŽ¯ Recursive Forecasting Predictions (${predictions.length} total)</h5>
                <p class="text-muted mb-3">PRIMARY prediction for next draw + SECONDARY recursive forecasts</p>
            </div>
        </div>
    `;
    
    // Show PRIMARY prediction first (highlighted)
    if (primaryPrediction) {
        const displayDate = formatDate(primaryPrediction.predicted_date);
        const confidence = primaryPrediction.confidence_score || 0;
        
        content += `
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card prediction-card shadow border-primary border-3" style="background: linear-gradient(135deg, #f8f9ff 0%, #e3f2fd 100%);">
                        <div class="card-header bg-primary text-white border-bottom">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-0">
                                        <i class="fas fa-star me-2"></i>
                                        ðŸŽ¯ PRIMARY PREDICTION - Next Draw
                                    </h5>
                                    <small class="opacity-75">${primaryPrediction.methodology || 'Next Draw Prediction'}</small>
                                </div>
                                <span class="badge bg-light text-primary fs-6 fw-bold">
                                    ${Math.round(confidence)}% Confidence
                                </span>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row text-center mb-3">
                                <div class="col-md-3">
                                    <div class="p-3 bg-white rounded shadow-sm">
                                        <h4 class="mb-1 text-primary"><i class="fas fa-calendar"></i></h4>
                                        <h5 class="mb-1 fw-bold">${displayDate}</h5>
                                        <small class="text-muted">Draw Date</small>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="p-3 bg-white rounded shadow-sm">
                                        <h4 class="mb-1 text-warning"><i class="fas fa-trophy"></i></h4>
                                        <h5 class="mb-1 fw-bold">${formatCRSWithCI(primaryPrediction.predicted_crs_score, primaryPrediction.uncertainty_range)}</h5>
                                        <small class="text-muted">CRS Score</small>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="p-3 bg-white rounded shadow-sm">
                                        <h4 class="mb-1 text-success"><i class="fas fa-users"></i></h4>
                                        <h5 class="mb-1 fw-bold">${(primaryPrediction.predicted_invitations || 0).toLocaleString()}</h5>
                                        <small class="text-muted">Invitations</small>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="p-3 bg-white rounded shadow-sm">
                                        <h4 class="mb-1 text-info"><i class="fas fa-brain"></i></h4>
                                        <h5 class="mb-1 fw-bold">${primaryPrediction.model_name || 'AI Model'}</h5>
                                        <small class="text-muted">Best Model</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    // Show SECONDARY predictions
    if (secondaryPredictions.length > 0) {
        content += `
            <div class="row mb-4">
                <div class="col-12">
                    <h5><i class="fas fa-forward me-2"></i>ðŸ”„ SECONDARY PREDICTIONS - Recursive Forecasts</h5>
                    <p class="text-muted mb-3">Each prediction builds on the previous one (recursive forecasting)</p>
                </div>
            </div>
            <div class="row">
        `;
        
        secondaryPredictions.forEach((prediction, index) => {
            const displayDate = formatDate(prediction.predicted_date);
            const confidence = prediction.confidence_score || 0;
            const rankColor = ['', 'primary', 'info', 'success', 'warning', 'secondary'][prediction.rank] || 'secondary';
            
            content += `
                <div class="col-lg-6 mb-4">
                    <div class="card prediction-card h-100 shadow-sm border-${rankColor}">
                        <div class="card-header bg-light border-bottom">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="mb-0 text-dark">
                                        <i class="fas fa-forward me-2 text-${rankColor}"></i>
                                        Rank ${prediction.rank} - ${displayDate}
                                    </h6>
                                    <small class="text-muted">${prediction.methodology || 'Recursive Forecast'}</small>
                                </div>
                                <span class="badge bg-${rankColor} text-white">
                                    ${Math.round(confidence)}%
                                </span>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row text-center">
                                <div class="col-4">
                                    <div class="p-2">
                                        <h5 class="mb-1 text-warning fw-bold">${formatCRSWithCI(prediction.predicted_crs_score, prediction.uncertainty_range)}</h5>
                                        <small class="text-muted">CRS Score</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div class="p-2">
                                        <h5 class="mb-1 text-success fw-bold">${(prediction.predicted_invitations || 0).toLocaleString()}</h5>
                                        <small class="text-muted">Invitations</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div class="p-2">
                                        <h5 class="mb-1 text-${rankColor} fw-bold">${prediction.model_name || 'AI'}</h5>
                                        <small class="text-muted">Model</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        });
        
        content += `</div>`; // Close secondary predictions row
    }
    
    return content;
}

function updateCategoryContent(categoryData) {
    const categoryName = categoryData.category_name;
    
    // Update titles
    document.getElementById('selectedCategoryTitle').textContent = `${categoryName} Performance`;
    document.getElementById('chartTitle').textContent = `${categoryName} Prediction Timeline`;
    
    // Update performance and chart for this category only
    displayModelPerformance([categoryData]);
    createTimelineChart([categoryData]);
    
    // Track prediction view
    if (window.trackPredictionView) {
        window.trackPredictionView(categoryName);
    }
}

function displayModelPerformance(categoryPredictions) {
    const container = document.getElementById('modelPerformance');
    container.innerHTML = '';
    
    if (!categoryPredictions || categoryPredictions.length === 0) return;
    
    const categoryData = categoryPredictions[0];
    const predictions = categoryData.predictions || [];
    
    // Handle new multi-model API structure
    let allModels = [];
    let allConfidences = [];
    let allInvitations = [];
    let nextCRSScore = 'N/A';
    
    predictions.forEach(predictionGroup => {
        if (predictionGroup.models && predictionGroup.models.length > 0) {
            // New format: predictions grouped by date with models array
            predictionGroup.models.forEach(model => {
                allModels.push(model.model_name || 'Unknown');
                allConfidences.push(model.confidence_score || 0);
                allInvitations.push(model.predicted_invitations || 0);
            });
            
            // Get next CRS score from the first prediction group (earliest date)
            if (nextCRSScore === 'N/A' && predictionGroup.models[0]) {
                nextCRSScore = predictionGroup.models[0].predicted_crs_score || 'N/A';
            }
        } else {
            // Old format fallback
            allModels.push(predictionGroup.model_used || 'Unknown');
            allConfidences.push(predictionGroup.confidence_score || 0);
            allInvitations.push(predictionGroup.predicted_invitations || 0);
            
            if (nextCRSScore === 'N/A') {
                nextCRSScore = predictionGroup.predicted_crs_score || 'N/A';
            }
        }
    });
    
    // Calculate metrics
    const avgConfidence = allConfidences.length > 0 ? 
        allConfidences.reduce((sum, c) => sum + c, 0) / allConfidences.length : 0;
    
    const uniqueModels = new Set(allModels);
    
    const avgInvitations = allInvitations.length > 0 ? 
        Math.round(allInvitations.reduce((sum, i) => sum + i, 0) / allInvitations.length) : 0;
    
    const lastUpdate = categoryData.last_updated ? 
        new Date(categoryData.last_updated).toLocaleDateString() : 'Unknown';
    
    const metrics = [
        {
            title: 'Average Confidence',
            value: `${Math.round(avgConfidence)}%`,
            icon: 'fas fa-thumbs-up',
            color: avgConfidence >= 70 ? 'success' : avgConfidence >= 50 ? 'warning' : 'danger'
        },
        {
            title: 'Avg. Invitations',
            value: avgInvitations > 0 ? avgInvitations.toLocaleString() : 'N/A',
            icon: 'fas fa-users',
            color: 'success'
        },
        {
            title: 'Active Models',
            value: `${uniqueModels.size} Models`,
            icon: 'fas fa-cogs',
            color: 'info'
        },
        {
            title: 'Next CRS Score',
            value: typeof nextCRSScore === 'number' ? Math.round(nextCRSScore) : nextCRSScore,
            icon: 'fas fa-trophy',
            color: 'warning'
        }
    ];
    
    metrics.forEach(metric => {
        const col = document.createElement('div');
        col.className = 'col-md-3 mb-3';
        
        col.innerHTML = `
            <div class="card text-center">
                <div class="card-body">
                    <i class="${metric.icon} fa-2x text-${metric.color} mb-3"></i>
                    <h4 class="mb-1">${metric.value}</h4>
                    <p class="mb-0 text-muted">${metric.title}</p>
                </div>
            </div>
        `;
        
        container.appendChild(col);
    });
}

function createTimelineChart(categoryPredictions) {
    if (!categoryPredictions || categoryPredictions.length === 0) {
        document.getElementById('timelineChart').innerHTML = '<p class="text-center text-muted">No data available for chart</p>';
        return;
    }
    
    const categoryData = categoryPredictions[0];
    const predictions = categoryData.predictions || [];
    
    // Handle new multi-model API structure - extract all model predictions
    const modelGroups = {};
    
    predictions.forEach(predictionGroup => {
        const date = predictionGroup.predicted_date;
        
        if (predictionGroup.models && predictionGroup.models.length > 0) {
            // New format: predictions grouped by date with models array
            predictionGroup.models.forEach(model => {
                const modelName = model.model_name || 'Unknown';
                if (!modelGroups[modelName]) {
                    modelGroups[modelName] = [];
                }
                modelGroups[modelName].push({
                    x: date,
                    y: model.predicted_crs_score || 0,
                    confidence: model.confidence_score || 75,
                    invitations: model.predicted_invitations || 0
                });
            });
        } else {
            // Old format fallback
            const modelName = predictionGroup.model_used || 'Unknown';
            if (!modelGroups[modelName]) {
                modelGroups[modelName] = [];
            }
            modelGroups[modelName].push({
                x: predictionGroup.predicted_date || new Date(),
                y: predictionGroup.predicted_crs_score || 0,
                confidence: predictionGroup.confidence_score || 75,
                invitations: predictionGroup.predicted_invitations || 0
            });
        }
    });
    
    // Create traces for each model with distinct colors
    const traces = Object.keys(modelGroups).map((modelName, index) => {
        const points = modelGroups[modelName].sort((a, b) => new Date(a.x) - new Date(b.x));
        const modelColor = getModelColor(modelName);
        
        return {
            x: points.map(p => p.x),
            y: points.map(p => p.y),
            mode: 'lines+markers',
            name: modelName,
            line: {
                color: modelColor,
                width: 3
            },
            marker: {
                color: modelColor,
                size: 8,
                opacity: 0.8
            },
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Date: %{x}<br>' +
                          'Predicted CRS: %{y}<br>' +
                          'Invitations: %{customdata.invitations}<br>' +
                          'Confidence: %{customdata.confidence}%<br>' +
                          '<extra></extra>',
            customdata: points.map(p => ({
                confidence: Math.round(p.confidence || 0),
                invitations: p.invitations && !isNaN(p.invitations) ? parseInt(p.invitations).toLocaleString() : 'N/A'
            }))
        };
    });
    
    if (traces.length === 0) {
        document.getElementById('timelineChart').innerHTML = '<p class="text-center text-muted">No model predictions available for chart</p>';
        return;
    }
    
    // Get current theme for chart styling
    const currentTheme = window.getCurrentTheme ? window.getCurrentTheme() : 'light';
    const isDark = currentTheme === 'dark';
    
    const layout = {
        title: {
            text: `${categoryData.category_name} - Multi-Model CRS Predictions`,
            font: { 
                size: 16,
                color: isDark ? '#E0E0E0' : '#2F2F2F'
            },
            y: 0.95
        },
        xaxis: {
            title: 'Prediction Date',
            type: 'date',
            gridcolor: isDark ? '#444444' : '#e0e0e0',
            linecolor: isDark ? '#666666' : '#cccccc',
            tickfont: { color: isDark ? '#E0E0E0' : '#2F2F2F' },
            titlefont: { color: isDark ? '#E0E0E0' : '#2F2F2F' }
        },
        yaxis: {
            title: 'Predicted CRS Score',
            rangemode: 'tozero',
            gridcolor: isDark ? '#444444' : '#e0e0e0',
            linecolor: isDark ? '#666666' : '#cccccc',
            tickfont: { color: isDark ? '#E0E0E0' : '#2F2F2F' },
            titlefont: { color: isDark ? '#E0E0E0' : '#2F2F2F' }
        },
        hovermode: 'closest',
        showlegend: true,
        legend: {
            orientation: 'v',
            x: 1.02,
            xanchor: 'left',
            y: 1,
            yanchor: 'top',
            font: { color: isDark ? '#E0E0E0' : '#2F2F2F' }
        },
        margin: {
            l: 60,
            r: 150,
            t: 80,
            b: 60
        },
        height: 500,
        paper_bgcolor: isDark ? '#1E1E1E' : '#ffffff',
        plot_bgcolor: isDark ? '#1E1E1E' : '#ffffff',
        font: { color: isDark ? '#E0E0E0' : '#2F2F2F' }
    };
    
    Plotly.newPlot('timelineChart', traces, layout, {responsive: true});
    
    // Add event tracking for chart interactions
    const chartElement = document.getElementById('timelineChart');
    if (chartElement && window.trackChartInteraction) {
        chartElement.on('plotly_hover', function() {
            window.trackChartInteraction('timeline_chart', 'hover');
        });
        
        chartElement.on('plotly_click', function() {
            window.trackChartInteraction('timeline_chart', 'click');
        });
        
        chartElement.on('plotly_legendclick', function() {
            window.trackChartInteraction('timeline_chart', 'legend_toggle');
        });
    }
    
    // Apply theme to the newly created chart
    if (window.applyThemeToChart) {
        setTimeout(() => {
            window.applyThemeToChart(document.getElementById('timelineChart'));
        }, 100);
    }
}

function refreshPredictions() {
    loadPredictions();
}

function filterByTimeframe() {
    if (currentCategory) {
        updateCategoryContent(currentCategory);
    }
}

// Utility functions
function calculateAverageInvitations(predictions) {
    if (!predictions || predictions.length === 0) return 'N/A';
    
    const validInvitations = predictions
        .map(p => p.predicted_invitations)
        .filter(inv => inv !== null && inv !== undefined && !isNaN(inv));
    
    if (validInvitations.length === 0) return 'N/A';
    
    const average = validInvitations.reduce((sum, inv) => sum + inv, 0) / validInvitations.length;
    
    if (isNaN(average)) return 'N/A';
    
    return Math.round(average).toLocaleString();
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

function formatCRSWithCI(score, uncertaintyRange) {
    const minScore = uncertaintyRange?.crs_min || uncertaintyRange?.min;
    const maxScore = uncertaintyRange?.crs_max || uncertaintyRange?.max;
    
    if (minScore !== undefined && maxScore !== undefined) {
        return `${score} (${minScore}â€“${maxScore})`;
    }
    return score.toString();
}

function formatInvitationsWithCI(invitations, uncertaintyRange) {
    if (!invitations && invitations !== 0) return 'N/A';
    
    // Ensure invitations is a valid number before formatting
    const invitationsNum = parseInt(invitations);
    if (isNaN(invitationsNum)) return 'N/A';
    
    const formattedInvitations = invitationsNum.toLocaleString();
    
    // Check for invitation-specific confidence intervals
    const minInvitations = uncertaintyRange?.invitations_min || uncertaintyRange?.min_invitations;
    const maxInvitations = uncertaintyRange?.invitations_max || uncertaintyRange?.max_invitations;
    
    if (minInvitations !== undefined && maxInvitations !== undefined) {
        const minNum = parseInt(minInvitations);
        const maxNum = parseInt(maxInvitations);
        
        if (!isNaN(minNum) && !isNaN(maxNum)) {
            const formattedMin = minNum.toLocaleString();
            const formattedMax = maxNum.toLocaleString();
            return `${formattedInvitations} (${formattedMin}â€“${formattedMax})`;
        }
    }
    
    return formattedInvitations;
}

function formatDateWithCI(predictedDate, uncertaintyRange) {
    if (!predictedDate) return 'N/A';
    
    const mainDate = new Date(predictedDate);
    const formattedMain = mainDate.toLocaleDateString('en-CA', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
    
    if (uncertaintyRange && uncertaintyRange.date_earliest && uncertaintyRange.date_latest) {
        const earliestDate = new Date(uncertaintyRange.date_earliest);
        const latestDate = new Date(uncertaintyRange.date_latest);
        
        const formattedEarliest = earliestDate.toLocaleDateString('en-CA', {
            month: 'short',
            day: 'numeric'
        });
        const formattedLatest = latestDate.toLocaleDateString('en-CA', {
            month: 'short', 
            day: 'numeric'
        });
        
        return `${formattedMain} (${formattedEarliest}â€“${formattedLatest})`;
    }
    
    return formattedMain;
}

function getModelColor(modelName) {
    const colors = {
        'Gaussian Process': '#198754',      // Green - easy on eyes
        'Bayesian Hierarchical': '#0dcaf0', // Light blue - soft
        'SARIMA': '#ffc107',               // Yellow - warm but not harsh
        'LSTM': '#6f42c1',                 // Purple - neutral
        'Prophet': '#fd7e14',              // Orange - warm
        'ARIMA': '#6c757d',                // Changed from red to neutral gray
        'Holt-Winters': '#20c997',         // Teal - calming
        'VAR': '#495057',                  // Dark gray - professional
        'Clean Linear Regression': '#0d6efd', // Blue - trust-inspiring
        'Advanced Ensemble': '#343a40'     // Darker gray - sophisticated
    };
    
    return colors[modelName] || '#6c757d'; // Default to neutral gray instead of blue
}

function getCategoryClass(categoryName) {
    if (!categoryName) return 'bg-secondary'; // Safe default for undefined category names
    
    const categoryClasses = {
        'Provincial Nominee Program': 'bg-primary',
        'Canadian Experience Class': 'bg-success',
        'Federal Skilled Worker': 'bg-info',
        'General': 'bg-secondary',
        'No Program Specified': 'bg-secondary',
        'French language proficiency': 'bg-warning',
        'Healthcare': 'bg-success', // Changed from bg-danger (red) to bg-success (green)
        'STEM': 'bg-dark'
    };
    
    for (const [key, className] of Object.entries(categoryClasses)) {
        if (categoryName.includes(key)) {
            return className;
        }
    }
    
    return 'bg-secondary'; // Changed from bg-light to bg-secondary for better contrast
}

function abbreviateCategoryName(categoryName) {
    const abbreviations = {
        'Canadian Experience Class': 'CEC',
        'Provincial Nominee Program': 'PNP',
        'Federal Skilled Worker': 'FSW',
        'Federal Skilled Trades': 'FST',
        'Agriculture and agri-food occupations': 'Agriculture',
        'Healthcare and social services occupations': 'Healthcare',
        'Education occupations': 'Education',
        'French language proficiency': 'French',
        'STEM occupations': 'STEM',
        'Trade occupations': 'Trades',
        'Transport occupations': 'Transport',
        'General': 'General'
    };
    
    // Check for exact matches first
    for (const [key, abbrev] of Object.entries(abbreviations)) {
        if (categoryName.includes(key)) {
            return abbrev;
        }
    }
    
    // Default: use first word if no match found
    const firstWord = categoryName.split(' ')[0];
    return firstWord.length > 12 ? firstWord.substring(0, 12) + '...' : firstWord;
}
</script>
{% endblock %} 
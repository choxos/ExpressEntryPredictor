{% extends 'base.html' %}

{% block title %}Express Entry Predictions - AI Forecasts{% endblock %}

{% block extra_css %}
<!-- Cache busting and refresh meta tags -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
{% endblock %}

{% block content %}
<!-- Header Section -->
<section class="hero-section">
    <div class="container">
        <div class="row">
            <div class="col-12 text-center">
                <h1 class="display-5 fw-bold mb-3">
                    <i class="fas fa-crystal-ball me-3"></i>
                    ðŸ‡¨ðŸ‡¦ Express Entry Predictions
                </h1>
                <p class="lead mb-0">
                    AI-powered forecasts for upcoming Canadian Express Entry draws using advanced machine learning models
                </p>
            </div>
        </div>
    </div>
</section>

<!-- Filter Section -->
<section class="container mb-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="row align-items-center">
                        <div class="col-md-4">
                            <label for="categoryFilter" class="form-label">Filter by Category:</label>
                            <select class="form-select" id="categoryFilter">
                                <option value="">All Categories</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="timeframe" class="form-label">Prediction Timeframe:</label>
                            <select class="form-select" id="timeframe">
                                <option value="next_month">Next Month</option>
                                <option value="next_quarter">Next Quarter</option>
                                <option value="rest_of_year" selected>Rest of Year</option>
                            </select>
                        </div>
                        <div class="col-md-4 d-flex align-items-end">
                            <button class="btn btn-primary w-100" onclick="refreshPredictions()">
                                <i class="fas fa-sync-alt me-2"></i>Refresh Predictions
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Predictions Grid -->
<section class="container mb-5">
    <div class="row" id="predictionsGrid">
        <div class="col-12">
            <div class="loading-spinner" id="predictionsLoading" style="display: block;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading predictions...</span>
                </div>
                <p class="mt-2">Generating AI predictions...</p>
            </div>
        </div>
    </div>
</section>

<!-- Model Performance Section -->
<section class="container mb-5">
    <div class="row">
        <div class="col-12">
            <h3 class="mb-4">
                <i class="fas fa-cogs me-2 text-primary"></i>
                Model Performance Overview
            </h3>
        </div>
    </div>
    
    <div class="row" id="modelPerformance">
        <!-- Model performance cards will be inserted here -->
    </div>
</section>

<!-- Prediction Timeline Chart -->
<section class="container mb-5">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-line me-2"></i>
                        Prediction Timeline
                    </h5>
                </div>
                <div class="card-body">
                    <div id="timelineChart" style="height: 500px;"></div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_js %}
<script>
let allPredictions = [];
let categories = [];

document.addEventListener('DOMContentLoaded', function() {
    loadCategories();
    loadPredictions();
    
    // Add event listeners for filtering
    document.getElementById('categoryFilter').addEventListener('change', filterPredictions);
    document.getElementById('timeframe').addEventListener('change', filterPredictions);
});

async function loadCategories() {
    try {
        const response = await axios.get('/api/categories/');
        categories = response.data.results || response.data;
        
        const categoryFilter = document.getElementById('categoryFilter');
        categoryFilter.innerHTML = '<option value="">All Categories</option>';
        
        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            categoryFilter.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading categories:', error);
    }
}

async function loadPredictions() {
    const loading = document.getElementById('predictionsLoading');
    const grid = document.getElementById('predictionsGrid');
    
    loading.style.display = 'block';
    
    try {
        // Add timestamp to prevent caching
        const timestamp = new Date().getTime();
        const response = await axios.get(`/api/predict/?t=${timestamp}`);
        const apiData = response.data;
        
        if (apiData.success && apiData.data && Array.isArray(apiData.data)) {
            console.log('Raw API data:', apiData.data);
            
            // Transform API data to match expected structure
            allPredictions = apiData.data.map(categoryData => {
                // Ensure predictions array exists and has data
                const predictions = categoryData.predictions || [];
                const firstPrediction = predictions[0] || {};
                
                return {
                    id: categoryData.category_id,
                    category_name: categoryData.category_name,
                    category: {
                        id: categoryData.category_id,
                        name: categoryData.category_name,
                        description: categoryData.category_description
                    },
                    predictions: predictions,
                    recent_draws: categoryData.recent_draws || [],
                    last_updated: categoryData.last_updated,
                    model_performance: {
                        accuracy: firstPrediction.confidence_score || 0,
                        model_used: firstPrediction.model_used || 'Unknown'
                    }
                };
            });
            
            console.log('Transformed predictions:', allPredictions);
            
            loading.style.display = 'none';
            displayPredictions(allPredictions);
            displayModelPerformance(allPredictions);
            createTimelineChart(allPredictions);
        } else {
            throw new Error('No prediction data available');
        }
        
    } catch (error) {
        loading.style.display = 'none';
        console.error('Error loading predictions:', error);
        console.error('Error stack:', error.stack);
        
        grid.innerHTML = `
            <div class="col-12">
                <div class="alert alert-danger text-center">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading predictions: ${error.message}. 
                    <br><br>
                    <strong>Try these steps:</strong>
                    <ol class="text-start mt-2 small">
                        <li>Press <kbd>Ctrl+F5</kbd> (or <kbd>Cmd+Shift+R</kbd> on Mac) to hard refresh</li>
                        <li>Clear your browser cache and reload</li>
                        <li>Check the browser console (F12) for detailed error messages</li>
                    </ol>
                </div>
            </div>
        `;
    }
}

function displayPredictions(predictions) {
    const grid = document.getElementById('predictionsGrid');
    grid.innerHTML = '';
    
    if (predictions.length === 0) {
        grid.innerHTML = `
            <div class="col-12">
                <div class="alert alert-info text-center">
                    <i class="fas fa-info-circle me-2"></i>
                    No predictions available. Try adjusting your filters.
                </div>
            </div>
        `;
        return;
    }
    
    predictions.forEach(prediction => {
        // Debug logging
        console.log('Processing prediction:', prediction);
        
        const categoryName = prediction.category?.name || prediction.category_name || 'Unknown';
        const categoryColor = getCategoryColor(categoryName);
        const nextPrediction = prediction.predictions?.[0]; // Get first prediction
        
        if (!nextPrediction) {
            console.error('No predictions found for category:', categoryName);
            return;
        }
        
        const confidence = nextPrediction.confidence_score;
        
        const col = document.createElement('div');
        col.className = 'col-lg-6 mb-4';
        
        col.innerHTML = `
            <div class="card h-100">
                <div class="card-header" style="background: ${categoryColor}; color: white;">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">${categoryName}</h6>
                        <span class="badge bg-light text-dark">
                            ${confidence}% Confidence
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-6">
                            <div class="text-center mb-3">
                                <i class="fas fa-calendar-alt fa-2x text-primary mb-2"></i>
                                <h5 class="mb-1">${formatDateWithCI(nextPrediction.predicted_date, nextPrediction.uncertainty_range)}</h5>
                                <small class="text-muted">Next Draw Date</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-center mb-3">
                                <i class="fas fa-trophy fa-2x text-warning mb-2"></i>
                                <h5 class="mb-1">${formatCRSWithCI(nextPrediction.predicted_crs_score, nextPrediction.uncertainty_range)}</h5>
                                <small class="text-muted">Predicted CRS</small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <h6>Upcoming Predictions:</h6>
                        <div class="prediction-timeline">
                            ${prediction.predictions.slice(0, 4).map(pred => `
                                <div class="d-flex justify-content-between py-1">
                                    <span>${formatDateWithCI(pred.predicted_date, pred.uncertainty_range)}</span>
                                    <strong>CRS: ${formatCRSWithCI(pred.predicted_crs_score, pred.uncertainty_range)}</strong>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="row text-center">
                        <div class="col-6">
                            <small class="text-muted">Model Used</small>
                            <div><strong>${nextPrediction.model_used}</strong></div>
                        </div>
                        <div class="col-6">
                            <small class="text-muted">Invitations</small>
                            <div><strong>${nextPrediction.predicted_invitations.toLocaleString()}</strong></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        grid.appendChild(col);
    });
}

function displayModelPerformance(predictions) {
    const container = document.getElementById('modelPerformance');
    container.innerHTML = '';
    
    // Calculate aggregate metrics from all individual predictions across categories
    let allPredictions = [];
    let totalConfidence = 0;
    let totalCategories = predictions.length;
    
    predictions.forEach(categoryData => {
        if (categoryData.predictions && Array.isArray(categoryData.predictions)) {
            allPredictions.push(...categoryData.predictions);
            
            // Use the first prediction's confidence as category confidence
            if (categoryData.predictions[0]) {
                totalConfidence += categoryData.predictions[0].confidence_score || 0;
            }
        }
    });
    
    const avgConfidence = totalCategories > 0 ? totalConfidence / totalCategories : 0;
    const totalPredictions = allPredictions.length;
    
    // Calculate model diversity
    const modelTypes = new Set(allPredictions.map(p => p.model_used || 'Unknown'));
    const avgModelConfidence = allPredictions.length > 0 ? 
        allPredictions.reduce((sum, p) => sum + (p.confidence_score || 0), 0) / allPredictions.length : 0;
    
    const metrics = [
        {
            title: 'Average Confidence',
            value: `${avgConfidence.toFixed(1)}%`,
            icon: 'fas fa-thumbs-up',
            color: 'success'
        },
        {
            title: 'Model Diversity',
            value: `${modelTypes.size} Models`,
            icon: 'fas fa-cogs',
            color: 'info'
        },
        {
            title: 'Overall Confidence',
            value: `${avgModelConfidence.toFixed(1)}%`,
            icon: 'fas fa-chart-line',
            color: 'warning'
        },
        {
            title: 'Total Predictions',
            value: totalPredictions.toString(),
            icon: 'fas fa-chart-bar',
            color: 'primary'
        }
    ];
    
    metrics.forEach(metric => {
        const col = document.createElement('div');
        col.className = 'col-md-3 mb-3';
        
        col.innerHTML = `
            <div class="card text-center">
                <div class="card-body">
                    <i class="${metric.icon} fa-2x text-${metric.color} mb-3"></i>
                    <h4 class="mb-1">${metric.value}</h4>
                    <p class="mb-0 text-muted">${metric.title}</p>
                </div>
            </div>
        `;
        
        container.appendChild(col);
    });
}

function createTimelineChart(predictions) {
    const chartData = [];
    
    predictions.forEach(prediction => {
        // Debug logging for data structure
        console.log('Chart prediction data:', prediction);
        
        // Use the correct property name: predictions instead of prediction_timeline
        const categoryName = prediction.category?.name || prediction.category_name || 'Unknown';
        
        if (prediction.predictions && Array.isArray(prediction.predictions)) {
            prediction.predictions.forEach(pred => {
                chartData.push({
                    x: pred.predicted_date,
                    y: pred.predicted_crs_score,
                    category: categoryName,
                    confidence: pred.confidence_score || 75
                });
            });
        } else {
            console.warn('No predictions array found for category:', categoryName);
        }
    });
    
    // Group by category
    const categoryGroups = {};
    chartData.forEach(point => {
        if (!categoryGroups[point.category]) {
            categoryGroups[point.category] = [];
        }
        categoryGroups[point.category].push(point);
    });
    
    const traces = Object.keys(categoryGroups).map(category => {
        const points = categoryGroups[category].sort((a, b) => new Date(a.x) - new Date(b.x));
        
        return {
            x: points.map(p => p.x),
            y: points.map(p => p.y),
            mode: 'lines+markers',
            name: abbreviateCategoryName(category),
            line: {
                width: 3
            },
            marker: {
                size: 8,
                opacity: 0.8
            },
            hovertemplate: '<b>%{fullData.name}</b><br>' +
                          'Date: %{x}<br>' +
                          'Predicted CRS: %{y}<br>' +
                          'Confidence: %{customdata}%<br>' +
                          '<extra></extra>',
            customdata: points.map(p => Math.round(p.confidence))
        };
    });
    
    const layout = {
        title: {
            text: 'Predicted CRS Scores Timeline',
            font: { size: 18 },
            y: 0.95
        },
        xaxis: {
            title: 'Date',
            type: 'date'
        },
        yaxis: {
            title: 'CRS Score',
            range: [300, 900]
        },
        hovermode: 'closest',
        showlegend: true,
        legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: -0.15,
            yanchor: 'top',
            bgcolor: 'rgba(255, 255, 255, 0.8)',
            bordercolor: 'rgba(0, 0, 0, 0.1)',
            borderwidth: 1
        },
        margin: {
            l: 60,
            r: 40,
            t: 80,
            b: 120
        },
        height: 450
    };
    
    Plotly.newPlot('timelineChart', traces, layout, {responsive: true});
}

function refreshPredictions() {
    loadPredictions();
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

function formatCRSWithCI(score, uncertaintyRange) {
    // Handle both old format (min/max) and new format (crs_min/crs_max)
    const minScore = uncertaintyRange?.crs_min || uncertaintyRange?.min;
    const maxScore = uncertaintyRange?.crs_max || uncertaintyRange?.max;
    
    if (minScore !== undefined && maxScore !== undefined) {
        return `${score} (${minScore}â€“${maxScore})`;
    }
    return score.toString();
}

function formatDateWithCI(predictedDate, uncertaintyRange) {
    if (!predictedDate) return 'N/A';
    
    // Format the main predicted date
    const mainDate = new Date(predictedDate);
    const formattedMain = mainDate.toLocaleDateString('en-CA', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
    
    // Check if we have date uncertainty range
    if (uncertaintyRange && uncertaintyRange.date_earliest && uncertaintyRange.date_latest) {
        const earliestDate = new Date(uncertaintyRange.date_earliest);
        const latestDate = new Date(uncertaintyRange.date_latest);
        
        // Format the range dates
        const formattedEarliest = earliestDate.toLocaleDateString('en-CA', {
            month: 'short',
            day: 'numeric'
        });
        const formattedLatest = latestDate.toLocaleDateString('en-CA', {
            month: 'short', 
            day: 'numeric'
        });
        
        return `${formattedMain} (${formattedEarliest}â€“${formattedLatest})`;
    }
    
    return formattedMain;
}

function getCategoryColor(categoryName) {
    const colors = {
        'Provincial Nominee Program': '#0d47a1',
        'Canadian Experience Class': '#28a745',
        'Federal Skilled Worker': '#17a2b8',
        'General': '#6c757d',
        'No Program Specified': '#6c757d',
        'French language proficiency': '#ffc107',
        'Healthcare': '#dc3545',
        'STEM': '#343a40'
    };
    
    for (const [key, color] of Object.entries(colors)) {
        if (categoryName.includes(key)) {
            return color;
        }
    }
    
    return '#007bff';
}

function abbreviateCategoryName(categoryName) {
    const abbreviations = {
        'Canadian Experience Class': 'CEC',
        'Provincial Nominee Program': 'PNP',
        'Federal Skilled Worker': 'FSW',
        'Federal Skilled Trades': 'FST',
        'Agriculture and agri-food occupations (Version 1)': 'Agriculture',
        'Healthcare and social services occupations (Version 2)': 'Health (v2)',
        'Healthcare occupations (Version 1)': 'Health (v1)',
        'Education occupations (Version 1)': 'Education',
        'French language proficiency (Version 1)': 'French',
        'STEM occupations (Version 1)': 'STEM',
        'Trade occupations (Version 1)': 'Trades',
        'Transport occupations (Version 1)': 'Transport',
        'No Program Specified': 'General',
        'General': 'General'
    };
    
    // Check for exact matches first
    if (abbreviations[categoryName]) {
        return abbreviations[categoryName];
    }
    
    // Check for partial matches
    for (const [key, abbrev] of Object.entries(abbreviations)) {
        if (categoryName.includes(key)) {
            return abbrev;
        }
    }
    
    // Default: use first word if no match found
    const firstWord = categoryName.split(' ')[0];
    return firstWord.length > 8 ? firstWord.substring(0, 8) + '...' : firstWord;
}

// Comprehensive filter functionality
function filterPredictions() {
    const selectedCategory = document.getElementById('categoryFilter').value;
    const selectedTimeframe = document.getElementById('timeframe').value;
    
    let filteredPredictions = allPredictions;
    
    // Filter by category
    if (selectedCategory) {
        filteredPredictions = filteredPredictions.filter(p => p.category.id == selectedCategory);
    }
    
    // Filter by timeframe
    if (selectedTimeframe) {
        filteredPredictions = filteredPredictions.map(categoryData => {
            const filteredCategoryPredictions = filterPredictionsByTimeframe(
                categoryData.predictions || [], 
                selectedTimeframe
            );
            
            return {
                ...categoryData,
                predictions: filteredCategoryPredictions
            };
        }).filter(categoryData => categoryData.predictions.length > 0);
    }
    
    displayPredictions(filteredPredictions);
    displayModelPerformance(filteredPredictions);
    createTimelineChart(filteredPredictions);
}

function filterPredictionsByTimeframe(predictions, timeframe) {
    if (!timeframe) return predictions;
    
    const now = new Date();
    let endDate;
    
    switch (timeframe) {
        case 'next_month':
            // Next month (until end of next month)
            endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            break;
        case 'next_quarter':
            // Next quarter (until end of current quarter + 1)
            const currentQuarter = Math.floor(now.getMonth() / 3);
            const nextQuarterEndMonth = (currentQuarter + 1) * 3;
            endDate = new Date(now.getFullYear(), nextQuarterEndMonth, 0);
            break;
        case 'rest_of_year':
            // Rest of year (until December 31)
            endDate = new Date(now.getFullYear(), 11, 31);
            break;
        default:
            return predictions;
    }
    
    return predictions.filter(pred => {
        const predDate = new Date(pred.predicted_date);
        return predDate <= endDate;
    });
}
</script>
{% endblock %} 